<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Lab 2: Multiplexed 7-Segment Display – D. Sebastian Heredia</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-07ba0ad10f5680c660e360ac31d2f3b6.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-09e026eaf2cc604157e76dc7fb526ea0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="viewport" content="width=device-width, initial-scale=0.5, maximum-scale=0.5, user-scalable=no">


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">D. Sebastian Heredia</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./E155_Labs.html"> 
<span class="menu-text">E155 Microprocessor Labs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./engineering.html"> 
<span class="menu-text">Engineering Class Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./projects.html"> 
<span class="menu-text">Personal Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./music.html"> 
<span class="menu-text">Music &amp; Performance</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./outdoors.html"> 
<span class="menu-text">Sports &amp; Outdoors</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lab 2: Multiplexed 7-Segment Display</h1>
<p class="subtitle lead">Sebastian Heredia | dheredia@g.hmc.edu | September 10, 2025</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p class="justify-text">
In this lab, time-divsion multiplexing (DTM) was implemented to drive a single dual 7-segment display with only nine FPGA I/O pins. The hexadecimal values displayed on each half of the dual 7-segment display were added and the sum was displayed as a 5-bit binary number on five external LEDs. Notably, PNP transistors were used to drive sufficient current to power the common anodes of the dual 7-segment display while respecting the FGPA’s current capacity.
</p>
<p class="justify-text">
In this system, the same hexadecimal signal from a DIP switch was sent to both halves of the dual 7-segment display. By powering only one common anode of the display at a time, only that corresponding side of the 7-segment display would light up. By quickly switching which anodes receiving power, the right and left sides of the display appeared to show two independent numbers simultaneously.
</p>
<div style="display: flex; gap: 10px;">
<p><a href="https://youtu.be/jsT2PJhZEE0" target="_blank"> <button style="border-radius: 6px; padding: 8px 14px; background-color: #ff0000; color: white; border: none; font-weight: bold; cursor: pointer;"> ▶ Lab 2: Multiplexing Video </button> </a></p>
<p><a href="https://github.com/DylanSebastianHeredia/E155_Lab_2" target="_blank"> <button style="border-radius: 6px; padding: 8px 14px; background-color: #1128dc; color: rgb(255, 255, 255); border: none; font-weight: bold; cursor: pointer;"> Code </button> </a></p>
</div>
</section>
<section id="methods-design" class="level2">
<h2 class="anchored" data-anchor-id="methods-design">Methods &amp; Design</h2>
<section id="lab-setup" class="level3">
<h3 class="anchored" data-anchor-id="lab-setup">Lab Setup</h3>
<p class="justify-text">
Given limited resources, time-multiplexing leverages synchronized timing to allow expensive hardware to be used for different purposes at designated times. <em>Figure 1</em> shows the physical setup of the lab which included two binary encoded quad DIP switches, one deep red <a href="https://docs.broadcom.com/doc/HDSP-521A-523A-Dual-Digit-General-Purpose-7-Segment-Display-DS">HDSP-521A</a> dual 7-segment showing hexadecimal numbers <code>0</code> to <code>F</code> on each side corresponding to the switch inputs, two <a href="https://www.onsemi.com/pdf/datasheet/2n3906-d.pdf">2N3906 PNP</a> transistors, and five green LEDs that represent the binary sum of the switch inputs.
</p>
<p><img src="images/E155_Lab2/setup.png" alt="Time-Multiplexing Setup" style="width:100%; border-radius: 15px;"> <em>Figure 1: Setup of the breadboarded system display</em> <code>8</code> <em>and</em> <code>A</code><em>, and their sum</em> <code>5'b10010</code> on the LEDs.</p>
<p class="justify-text">
To implement the desired function, the signals shown in <em>Table 1</em> were used. Notably, the <code>sevensegment.sv</code> module from Lab 1 reused to convert quad DIP switch inputs to visual numbers on the 7-segment displays.
</p>
<p><br> <em>Table 1: Signal name, type, and brief description for each signal used in the project.</em></p>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>Signal Name</th>
<th>Signal Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>clk</code></td>
<td>input</td>
<td>48MHz clock on FPGA</td>
</tr>
<tr class="even">
<td><code>reset</code></td>
<td>input</td>
<td>Turns off display when held</td>
</tr>
<tr class="odd">
<td><code>s0[3:0]</code></td>
<td>input</td>
<td>Switch for left display number</td>
</tr>
<tr class="even">
<td><code>s1[3:0]</code></td>
<td>input</td>
<td>Switch for right display number</td>
</tr>
<tr class="odd">
<td><code>select</code></td>
<td>output</td>
<td>Power for left display number</td>
</tr>
<tr class="even">
<td><code>notselect</code></td>
<td>output</td>
<td>Power for right display number</td>
</tr>
<tr class="odd">
<td><code>led[4:0]</code></td>
<td>output</td>
<td>5 LEDS to display sum</td>
</tr>
<tr class="even">
<td><code>seg[6:0]</code></td>
<td>output</td>
<td>Dual 7-segment display segments</td>
</tr>
</tbody>
</table>
<p><br></p>
</section>
</section>
<section id="technical-documentation" class="level2">
<h2 class="anchored" data-anchor-id="technical-documentation">Technical Documentation</h2>
<p class="justify-text">
The project was contructued using two modules: <a href="https://github.com/DylanSebastianHeredia/E155_Lab_2/blob/main/fpga/src/lab2_dsh.sv">lab2_dsh.sv</a> and <a href="https://github.com/DylanSebastianHeredia/E155_Lab_2/blob/main/fpga/src/sevensegment.sv">sevensegment.sv</a>. In addition, the <code>HSOSC</code> library was reused to generate a system counter to toggle between powering each side of the display. <em>Figure 2</em> shows SystemVerilog module hierarchy block diagram.
</p>
<p><img src="images/E155_Lab2/updated_block.jpg" alt="Lab 2 Block Diagram" style="width:100%; border-radius: 15px;"> <em>Figure 2: Block diagram representation of SystemVerilog module hierarchy.</em></p>
<section id="multiplexing-implentation-in-lab1_dsh.sv" class="level3">
<h3 class="anchored" data-anchor-id="multiplexing-implentation-in-lab1_dsh.sv">Multiplexing Implentation in <code>lab1_dsh.sv</code></h3>
<p class="justify-text">
Given fewer FPGA I/O pins than pins on the dual 7-segment display, a multiplexer was used to select which switch input should be fed into the 7-segment display at a given time. The signal to toggle the multiplexer was the internal variable <code>state</code> was a slowed down version of the <code>HSOSC</code> clock native to the board. In order to synchronize the multiplexing of the switch inputs with their visual numbers on the display, <code>state</code> was directly set to toggle output variables <code>select</code> and <code>notselect</code> which correspond to powering the left and right common anodes of the dual 7-segment display, respectively. Importatnly, <code>state</code> was set to toggle at at a frequency of 240Hz means a given display side flashes 120 per second—a rate faster than the human eye can detect which ensured seamless appearance.
</p>
</section>
<section id="adding-implentation-in-lab1_dsh.sv" class="level3">
<h3 class="anchored" data-anchor-id="adding-implentation-in-lab1_dsh.sv">Adding Implentation in <code>lab1_dsh.sv</code></h3>
<p class="justify-text">
A simple adder was used to determine the sum of the DIP switch values. The sum was stored in the output variable <code>led</code> and bit LED was assigned a bit such that the sequence would correctly display the sum in binary.
</p>
</section>
<section id="segment-implementation-in-sevensegment.sv" class="level3">
<h3 class="anchored" data-anchor-id="segment-implementation-in-sevensegment.sv">7-Segment Implementation in <code>sevensegment.sv</code></h3>
<p class="justify-text">
Identical to Lab 1, the 7-segment display was designed using combinational logic to map all quad DIP switch cases to output number <code>0</code> to <code>F</code> on the display. Furthermore, <em>Figure 3</em> shows the schematic for how the two DIP switches, dual 7-segment display, PNP transistor, and five LEDs were wired to the FPGA. Furthermore, <em>Figure 4</em> provides justification for all current limiting resistors since the FPGA can sustain a maximum current of 8mA.
</p>
<p><img src="images/E155_Lab2/new_schematic.jpg" alt="Lab 2 Circuit Schematic" style="width:100%; border-radius: 15px;"> <em>Figure 3: Schematic showing the wiring of all componts to the FPGA.</em></p>
<p><img src="images/E155_Lab2/calculations.jpg" alt="Resistor Calculations" style="width:100%; border-radius: 15px;"> <em>Figure 4: Calculations to justify current limiting resistor values through the PNP transistor base, green LEDs, and dual 7-segment display.</em></p>
</section>
</section>
<section id="results-discussion" class="level2">
<h2 class="anchored" data-anchor-id="results-discussion">Results &amp; Discussion</h2>
<p class="justify-text">
The design accomplished all the intended tasks. <a href="https://github.com/DylanSebastianHeredia/E155_Lab_2/tree/main/fpga/sim">Testbenches</a> for both <code>lab2_dsh.sv</code> and <code>sevensegment.sv</code> modules were succesfully simulated in Questa to verify correct LED sum, correct segmenet display representation, and that displays toggle between ON and OFF and are never the same value. All 256 addition combinations were simulated in the testbench using a loop. <em>Figure 5</em> shows that <code>lab2_dsh.sv</code> matches all expectations. <em>Figure 6</em> shows that <code>sevensegment.sv</code> also matches all expectations.
</p>
<p><img src="images/E155_Lab2/lab2_dsh_tb.png" alt="lab2_dsh.sv WaveSim" style="width:100%; border-radius: 15px;"> <em>Figure 5: Multiplexing, adding, and LED displaying features simulated as expected in Questa for</em> <code>lab2_dsh.sv</code> <em>for all combinations of switch inputs.</em></p>
<p><img src="images/E155_Lab2/sevensegment_tb.png" alt="sevensegment.sv WaveSim" style="width:100%; border-radius: 15px;"> <em>Figure 6: All 7-segment display outcomes matched expectation in Questa for</em> <code>sevensegment.sv</code>.</p>
</section>
<section id="conclusion-demo" class="level2">
<h2 class="anchored" data-anchor-id="conclusion-demo">Conclusion &amp; Demo</h2>
<p class="justify-text">
All designs were successfully implemented. All simulations matched expectation and the physical hardware behaved as intended. The lab took 15 hours to complete.
</p>
<p class="justify-text">
Beyond reinforcing concepts of time-multiplexing to overcome challenges with limited hardware, I also gained valuable practice with hardware-aware digital design. That is, I learned how to integrate PNP transistors to source current common-anode displays, calculate and justify current-limiting resistor values using datasheets, and synchronize a divided oscillator signal with human perception to achieve a smooth visual output. This lab also strengthened my workflow of simulating modules in Questa prior to hardware implementation, which helped ensure correctness and streamline debugging.
</p>
<p><a href="https://youtu.be/jsT2PJhZEE0" target="_blank"> <button style="border-radius: 6px; padding: 8px 14px; background-color: #ff0000; color: white; border: none; font-weight: bold; cursor: pointer;"> ▶ Lab 2: Multiplexing Video </button> </a></p>
<section id="ai-prototype" class="level3">
<h3 class="anchored" data-anchor-id="ai-prototype">AI Prototype</h3>
<p>The purpose of the AI Prototype is to experiment with usign AI as a coding assistant to produce HDL. The following prompt was entered to ChatGPT 5.0.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
LLM Prompt
</div>
</div>
<div class="callout-body-container callout-body">
<p>Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.</p>
</div>
</div>
<p class="justify-text">
Within 10 seconds of <em>thinking</em>, ChatGPT 5.0 produced a SystemVerilog script that was capable of being synthesized in Lattice Radiant on the first try. <em>Figure 7</em> below shows the RTL schematic of the generated script. Looking at the schematic, the number of inputs matches expectations as there are two 4-bit inputs, clk, and reset. In terms of outputs, the schematic correctly shows two sets of 7-segment displays as well as toggle bits held in <code>anode[1:0]</code>, however, there is an extra set of outputs called <code>seg_bus[6:0]</code> which appears to acts a docking location for the display value before it is output on <code>seg[0]</code> or <code>seg[1]</code>. Nevertheless, <code>seg_bus[6:0]</code> should be an internal variable not an output.
</p>
<p><img src="images/E155_Lab2/lab2_ai_v1.png" alt="sevensegment.sv WaveSim" style="width:100%; border-radius: 15px;"> <em>Figure 7: RLT schematic of the SystemVerilog script produced by ChatGPT 5.0.</em></p>
<p class="justify-text">
Within the same AI conversation with the LLM, the following follow-up prompt was asked.
</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
LLM Prompt
</div>
</div>
<div class="callout-body-container callout-body">
<p>Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.</p>
</div>
</div>
<p class="justify-text">
For some reason, when sharing my Lab 1 files with ChatGPT, it was unable to produce a script capable of being synthesized in Lattice Radiant. I prompted the LLM three times, encouraging it to implement insights from the attached documents and it was never able to correctly do so.
</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/DylanSebastianHeredia\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>