<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Lab 4: Digital Audio – D. Sebastian Heredia</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-07ba0ad10f5680c660e360ac31d2f3b6.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-09e026eaf2cc604157e76dc7fb526ea0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="viewport" content="width=device-width, initial-scale=0.5, maximum-scale=0.5, user-scalable=no">


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">D. Sebastian Heredia</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./engineering.html"> 
<span class="menu-text">Engineering Class Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./projects.html"> 
<span class="menu-text">Personal Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./music.html"> 
<span class="menu-text">Music &amp; Performance</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./outdoors.html"> 
<span class="menu-text">Sports &amp; Outdoors</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-e155-microprocessor-labs" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">E155 Microprocessor Labs</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-e155-microprocessor-labs">    
        <li>
    <a class="dropdown-item" href="./E155_Lab_1.html">
 <span class="dropdown-text">Lab 1 - FPGA &amp; MCU Setup</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./E155_Lab_2.html">
 <span class="dropdown-text">Lab 2 - Time Multiplexing</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./E155_Lab_3.html">
 <span class="dropdown-text">Lab 3 - Keypad Scanner</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./E155_Lab_4.html">
 <span class="dropdown-text">Lab 4 - Digital Audio</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="./blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lab 4: Digital Audio</h1>
<p class="subtitle lead">Sebastian Heredia | dheredia@g.hmc.edu | October 1, 2025</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p class="justify-text">
In this lab, the internal peripheral timers of the <a href="https://hmc-e155.github.io/assets/doc/ds11451-stm32l432kc.pdf">STM32L432KC MCU</a> were used to drive a small speaker to play music. To implement this function, the PWM timers on the MCU generated square waves to toggle a GPIO pin at a specific frequency and manage note duration. The MCU was programmed to play <em>Für Elise</em> by Beethoven and <em>Blue (Da Be Dee)</em> by Eiffel 65.
</p>
<p><a href="https://github.com/DylanSebastianHeredia/E155_Lab_4" target="_blank"> <button style="border-radius: 6px; padding: 8px 14px; background-color: #1128dc; color: rgb(255, 255, 255); border: none; font-weight: bold; cursor: pointer;"> Code </button> </a></p>
</section>
<section id="methods-design" class="level2">
<h2 class="anchored" data-anchor-id="methods-design">Methods &amp; Design</h2>
<section id="lab-overview" class="level3">
<h3 class="anchored" data-anchor-id="lab-overview">Lab Overview</h3>
<p class="justify-text">
The goals of the lab were twofold: 1) Build a circuit to enable an I/O pin from the MCU to drive a speaker and 2) Write libraries in C from scratch. To meet the outlined goals, two timers were developed. First, timer TIM15 was used to generate precise millisecond delays for note durations. Second, timer TIM16 was used to produce PWM signals corresponding to musical notes. The GPIO pin PA6 was configured to use alternate function 14 so that the TIM16 output could be routed to the audio circuit. Then, the main program iterated through arrays containing note frequencies (Hz) and durations (ms), updating the PWM output for each note and delaying the program execution according to the specified note length. This setup allowed the MCU to function as a digital audio synthesizer capable of playing sequences of notes with varying pitches.
</p>
<p class="justify-text">
Custom headers were written for the <code>RCC</code>, <code>GPIO</code>, and <code>TIM</code> modules to allow direct access to registers and bit manipulation. This was necessary to configure clocks, timers, and GPIOs. By defining the timer registers in <code>TIM.h</code> as structured data, specific registers could be modified for PWM output or delay control.
</p>
</section>
<section id="clock-control" class="level3">
<h3 class="anchored" data-anchor-id="clock-control">Clock Control</h3>
<p class="justify-text">
The system clock, running at 80MHz, was routed through the reset-control clock (<code>RCC</code>) to the timers and GPIO peripherals. The timer TIM16 input clock was scaled down using a prescaler (<code>PSC</code>) of 79 to generate frequency of 1 MHz. The timer TIM15 clock prescaler was set to 3000 to correctly span the full range of delays. Enabling the peripherals and setting prescalers involved setting the appropriate bits in the RCC registers, specifically in <code>AHB2ENR</code> and <code>APB2ENR</code>. The prescaler values were chosen to accommodate the range of frequencies required for musical notes and the range of durations found in the note arrays.
</p>
</section>
<section id="timer-setup" class="level3">
<h3 class="anchored" data-anchor-id="timer-setup">Timer Setup</h3>
<p class="justify-text">
TIM15 was configured to generate precise delays corresponding to note durations. Its prescaler scaled the 80MHz system clock down to a practical frequency for millisecond timing. The auto-reload register (<code>ARR</code>) was set based on the desired delay in milliseconds by scaling the system clock, and the program waited for the update interrupt flag before continuing execution. This method allowed accurate timing for each note and enabled simple modificaiton of tempos by modifying the note duration arrays.
</p>
<p class="justify-text">
TIM16 was configured to generate PWM signals for audio output. The prescaler reduced the clock to 1MHz, and the <code>ARR</code> was calculated as the timer clock divided by the note frequency. The capture/compare register <code>CCR1</code> was set to half of the auto-reload value to produce a square wave with a 50% duty cycle. PWM mode 1 with preload enabled ensured smooth waveform output. The output was routed to <code>PA6</code> using alternate function 14. Frequency changes were handled dynamically using the <code>setPWM()</code> function, which updated ARR and <code>CCR1</code> for each note without glitches.
</p>
<p class="justify-text">
The main program first configured wait states and system clocks, then enabled the necessary GPIO and timer peripherals. TIM16 PWM was initialized with 40 Hz (A4) and the program played <em>Für Elise</em> by iterating through the note arrays, updating TIM16 frequency, and delaying each note with TIM15. After a one-second pause, TIM16 was reinitialized and the program played <em>Blue (Da Ba Dee)</em>. Finally, TIM16 was stopped to end the tunes.
</p>
</section>
</section>
<section id="calculations" class="level2">
<h2 class="anchored" data-anchor-id="calculations">Calculations</h2>
<p class="justify-text">
The prescaler (<code>PSC</code>) value divides the system clock frequency of 80MHz by any factor between 1 and 65,536. <em>Figure 1</em> anf <em>Figure 2</em> below show calculations for the maximum and minimum values for frequency and duration components based on the selected <code>PSC</code> and contraints for the auto-reload register (<code>ARR</code>) noted in the <a href="https://hmc-e155.github.io/assets/doc/rm0394-stm32l41xxx42xxx43xxx44xxx45xxx46xxx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">STM32L432KC Reference Manual</a>.
</p>
<div style="display: flex; flex-direction: row; flex-wrap: wrap; gap: 20px;">
<div style="flex: 2; width: 300px;">
<img src="images/E155_Lab4/freq_calc.jpg" alt="Frequency range calculations" style="width:100%; border-radius: 15px;">
<div style="height: 10px;">

</div>
<p>
<em>Figure 1: Frequency range based on</em> <code>PSC = 79</code>.
</p>
</div>
<div style="flex: 2; min-width: 300px;">
<img src="images/E155_Lab4/duration_calc.jpg" alt="Duration range calculations" style="width:100%; border-radius: 15px;">
<div style="height: 10px;">

</div>
<p>
<em>Figure 2: Duration range based on</em> <code>PSC = 3000</code>.
</p>
</div>
</div>
<p class="justify-text">
After verifying the maximum and minimum frequencies and durations according to the selected <code>PSC</code> values, the frequency accuracy was quntified for the range 200Hz to 1,000Hz. All frequencies in this range were to be within 1% of their expected value. The calculations shown in <em>Figure 3</em> below verify this accuracy.
</p>
<img src="images/E155_Lab4/frequency_tolerance_calc.jpg" alt="1% frequency tolerance range" style="width:80%; border-radius: 15px;">
<p>
<br> <em>Figure 3: Calculations verify that pitches were within 1% across range 220Hz to 1,000Hz.</em>
</p>
</section>
<section id="technical-documentation" class="level2">
<h2 class="anchored" data-anchor-id="technical-documentation">Technical Documentation</h2>
<p class="justify-text">
The TIM16 output on <code>PA6</code> was connected to a small speaker through an LM348 audio amplifier to boost the 5.0V MCU signal to audible levels. A 10kΩ potentiometer allowed volume control. This setup provided sufficient volume while protecting the MCU from excessive current draw. <em>Figure 4</em> below shows the electrical schematic for the design.
</p>
<p><img src="images/E155_Lab4/lab4_schematic.jpg" alt="Lab 4 Schematic" style="width:100%; border-radius: 15px;"> <em>Figure 4: Schematic showing the design used a LM386N amplifier to provide sufficient voltage through the speaker.</em></p>
</section>
<section id="results-discussion" class="level2">
<h2 class="anchored" data-anchor-id="results-discussion">Results &amp; Discussion</h2>
<p class="justify-text">
The final implementation successfully played <em>Für Elise</em> and <em>Blue (Da Be Dee)</em> with correct pitches and note durations. The millisecond delay provided by TIM15 and the PWM output from TIM16 worked together to generate accurate and clear musical notes. Volume control through the potentiometer functioned as intended.
</p>
</section>
<section id="conclusion-demo" class="level2">
<h2 class="anchored" data-anchor-id="conclusion-demo">Conclusion &amp; Demo</h2>
<p class="justify-text">
All designs were successfully implemented. The lab took <strong>24 hours</strong> to complete.
</p>
<p class="justify-text">
The lab reinforced the importance of prcise timers configuration and sequencingin PWM updates for digital audio. Notable challenges included ensuring smooth PWM output when changing frequencies, accurately calculating PSC and ARR values for a wide range of notes, and finding base addresses in the MCU datasheet. After overcoming these challenges, the implementation was capable of playign mutiple songs with correct pitch and timing, which provided practical experience with bare-metal C programming.
</p>
<section id="ai-prototype" class="level3">
<h3 class="anchored" data-anchor-id="ai-prototype">AI Prototype</h3>
<p>The purpose of the AI Prototype is to experiment with usign AI as a coding assistant to navigate memory maps and guide the configuration of various peripherals. The following prompt was entered to ChatGPT 5.0.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
LLM Prompt
</div>
</div>
<div class="callout-body-container callout-body">
<ol type="1">
<li>What timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz?</li>
<li>What’s the best choice of timer if I want to easily connect it to a GPIO pin?</li>
<li>What formulae are relevant, and what registers need to be set to configure them properly?</li>
</ol>
</div>
</div>
<p class="justify-text">
For Question 1, the LLM suggested using TIM1, TIM2, TIM15, TIM16, TIM17 as they are general-purpose or advanced timers capable of direclty driving GPIO. This is very resonable to me because I implemented TIM15 and TIM16 in my own design approach. Notably, the <a href="https://hmc-e155.github.io/assets/doc/rm0394-stm32l41xxx42xxx43xxx44xxx45xxx46xxx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">STM32L432KC Reference Manual</a>. was provided along with the prompts above.
</p>
<p class="justify-text">
For Question 2, the LLM proposed using TIM2 as a timer since TIM2_CH1 is available on <code>PA0</code> which is a very accessible GPIO pin. The LLM also recommended usign TIM16_CH1 on <code>PA6</code>. This is reasonable to me because I used <code>PA6</code> to map directly to GPIO pins with alternate function mode.
</p>
<p class="justify-text">
For Question 3, the LLM provided the formulas shown in <em>Figure 5</em> below as well as advice on how to configure registers correctly. Both the formulas and register configuration approach are valid.
</p>
<img src="images/E155_Lab4/ai_prototype4.png" alt="Lab 4 AI prototype" style="width:50%; border-radius: 15px;">
<p>
<br> <em>Figure 5: LLM response to relevant formula for selecting</em> <code>ARR</code> <em>and</em> <code>PSC</code>.
</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/DylanSebastianHeredia\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>